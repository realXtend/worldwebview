<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js canvas - panorama demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: rgb(200,200,200);
                margin: 0px;
                overflow: hidden;
		position: relative;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                color: #ffffff;
                padding: 5px;
                font-family:Monospace;
                font-size:13px;
                font-weight: bold;
                text-align:center;
            }

            #button {
		position: absolute;
		left: 5px;
		top: 5px;
                font-family:Monospace;
                font-size:13px;
                font-weight: bold;
                text-align:center;
	    }

	    #map {
		position: absolute;
		display: block;
		top: 5px;
		right: 5px;
		width: 200px;
		height: 200px;
	    }

            a {
                color: #ffffff;
            }
        </style>
    </head>
    <body>

        <div id="container"></div>
        <div id="info">realXtend WebView</div>
        <!--<div id="button"><form name="res"><button name="resolution" onClick="return handleClick();">Switch to highres</button></form></div>-->
        <div id="map"><canvas id="mapCanvas" height="200" width="200"></canvas></div>
    
        <script src="three.js/build/three.min.js"></script>
        <script src="three.js/examples/js/Detector.js"></script>


    <script>

// TODO
// * LVM scene
// * POIs for lvm skene
// * arrow keys to move between POIs
// * nicer transitions

var isMobile = {
    Android: function() {
        return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i);
    },
    iOS: function() {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function() {
        return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function() {
        return navigator.userAgent.match(/IEMobile/i);
    },
    any: function() {
        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
    }
};

var XMLHttpFactories = [
    function () {return new XMLHttpRequest()},
    function () {return new ActiveXObject("Msxml2.XMLHTTP")},
    function () {return new ActiveXObject("Msxml3.XMLHTTP")},
    function () {return new ActiveXObject("Microsoft.XMLHTTP")}
];

var camera, scene, renderer;
var texture_placeholder, loadMaterial,
cube, isUserInteracting = false, previewReady = false,
onMouseDownMouseX = 0, onMouseDownMouseY = 0,
lon = 0, onMouseDownLon = 0, size = 1024, segments = 17,
lat = 0, onMouseDownLat = 0, mapImage = new Image(),
phi = 0, theta = 0, mesh, mapLoaded = false, mapElement,
target = new THREE.Vector3();

var materials = [];
var previewMaterials = [];

//var screenshot_server = 'http://studio.kyperjokki.fi:8886';
//var screenshot_server = 'http://192.168.100.47:8886';
//var screenshot_server = 'http://10.20.209.3:8886';
//var screenshot_server = 'http://studio.kyperjokki.fi:8886'
var screenshot_server = 'http://localhost:8886';

// var positions = [[86, -50, 164, 180],
// 		 [0, 0, 0, 90],
// 		 [0, -10, 0, 45],
// 		 [106, -70, 122, 90]];

// positions are of the form [x, y, z, rotY, rotX] 
var positions = [[31, 43, 46, 13, -19],
                 [-159, 30, -67, -73, -11],
                 [21, 9.5,-166, 150, 0],
                 [126, 23, -135, 148, -16],
                 [151, 22, 24, 60, -13],
                ];

// the y-coordinate of the map is used to get the map image right
var mapCenter = [-2, 242, -28];
var mapTopRightCorner = [223, 200];

var index = 0;

init();

function init() {
    var container;

    mapElement = document.getElementById('mapCanvas');


    for (var i = 0; i < 6; i++) {
        var texture = new THREE.Texture(texture_placeholder);
        var material = new THREE.MeshBasicMaterial({map: texture, overdraw: true});
        materials.push(material);
    }

    for (var i = 0; i < positions.length; i++) {
        previewMaterials.push([]);
    }

    container = document.getElementById('container');
    
        
    if (isMobile.any()) {
	console('This is mobile');
        segments = 9;
        size = 512;
    } else {
	console.log('Probably this is desktop');
    }

    get_map();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

    scene = new THREE.Scene();

    texture_placeholder = document.createElement('canvas');
    texture_placeholder.width = 128;
    texture_placeholder.height = 128;

    var context = texture_placeholder.getContext('2d');
    context.fillStyle = 'rgb(200, 200, 200)';
    context.fillRect(0, 0, texture_placeholder.width, texture_placeholder.height);

    //make loading material
    var texture = new THREE.Texture(texture_placeholder);
    loadMaterial = new THREE.MeshBasicMaterial({ map: texture, overdraw: true });

    Cube = new THREE.Mesh(new THREE.CubeGeometry(300, 300, 300, segments, segments, segments, materials), new THREE.MeshFaceMaterial());
    cube.scale.x = - 1;
    scene.add(cube);

    console.log('Detecting...');
    var useWebgl = false

    if (Detector.webgl) {
    	useWebgl = true
    	console.log('Found webgl');
    } else {
    	console.log('Using canvas fallback');
    }
    
    if (useWebgl) {
    	renderer = new THREE.WebGLRenderer();
    } else {
    	renderer = new THREE.CanvasRenderer();
    }
    
    //wait some time before loading the images
    setTimeout(getPreviewImages, 4000);


    renderer.setSize(window.innerWidth, window.innerHeight);

    container.appendChild(renderer.domElement);

    changePlace(positions[0][0], positions[0][1], positions[0][2], positions[0][3], positions[0][4]);

    container.addEventListener('mousedown', onDocumentMouseDown, false);
    container.addEventListener('mousemove', onDocumentMouseMove, false);
    container.addEventListener('mouseup', onDocumentMouseUp, false);
    container.addEventListener('mousewheel', onDocumentMouseWheel, false);

    container.addEventListener('touchstart', onDocumentTouchStart, false);
    container.addEventListener('touchmove', onDocumentTouchMove, false);

    document.addEventListener('keyup', onDocumentKeyUp, false);

    mapElement.addEventListener("click", onMapClick, false);

    window.addEventListener('resize', onWindowResize, false);

}

function handleClick() {
    if (size == 512) {
	size = 1024;
	document.forms.res.resolution.innerHTML = 'Switch to lowres';
    } else { 
	size = 512;
	document.forms.res.resolution.innerHTML='Switch to highres';
    }
    changePlace(positions[index][0], positions[index][1], positions[index][2], positions[index][3], positions[index][4]);
    return false;
}

function d(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

function onMapClick(event) {
    event.preventDefault();

    if (!event)
	event = window.event;
    
    //IE9 & Other Browsers
    if (event.stopPropagation) {
	event.stopPropagation();
    }
    //IE8 and Lower
    else {
	event.cancelBubble = true;
    }
    
    var mx = event.pageX - (window.innerWidth - 205);
    var my = event.pageY - 5;
    var hitIndex = null;
    for (var i = 0; i < positions.length; i++) {
    	var pos = positions[i];
    	var p = world2map(new THREE.Vector2(pos[0], pos[2]));
	if (d(mx, my, p.x, p.y) <= 5) {
	    hitIndex = i;
	}
    }
    if (hitIndex !== null) {
	index = hitIndex;
	var p = positions[index];
	changePlace(p[0], p[1], p[2], p[3], p[4]);
    }
}

function world2map(wCoords) {
    mCoords = new THREE.Vector2();
    // mCoords.x = -0.3787 * wCoords.x + 132.5680;
    // mCoords.y = -0.3855 * wCoords.y + 163.2289;
    
    var ax = (mapElement.width / 2) / (mapCenter[0] - mapTopRightCorner[0]);
    var bx = -mapTopRightCorner[0] * ax;
    
    var ay = (mapElement.height / 2) / (mapCenter[2] - mapTopRightCorner[1]);
    var by = -mapTopRightCorner[1] * ay;

    mCoords.x = ax * wCoords.x + bx;
    mCoords.y = ay * wCoords.y + by;

    return mCoords;
}

function get_map() {
    //var map_uri = screenshot_server + "/renderimg?posX=86&posY=164&posZ=164&ortX=0&ortY=0.7071067811865476&ortZ=0.7071067811865476&ortW=0"
    var map_uri = screenshot_server + "/renderimg?posX=" + mapCenter[0] + "&posY=" + mapCenter[1] + "&posZ=" + mapCenter[2] + "&ortX=0&ortY=0.7071067811865476&ortZ=0.7071067811865476&ortW=0"
    console.log("loading <a href=\"" + map_uri + "\">map</a>");
    //use indirect loading
    sendRequest(map_uri, function(req) {
        var mapurl = req.responseText;
        console.log("map url: " + req + " - " + mapurl);
	map_img = new Image();
	map_img.onload = function() {
	    mapImage = map_img;
	    mapLoaded = true;
	}
        map_img.src = mapurl;
    });
}

function drawMap(x, y, angle) {
    var v = world2map(new THREE.Vector2(x, y));
    var x = v.x;
    var y = v.y;

    //x, y is the center point on map coortinates
    //angle is the way we roll
    var canvas = document.getElementById('mapCanvas');
    var ctx = canvas.getContext('2d');

    //draw map
    if (mapLoaded) {
	ctx.drawImage(mapImage, 0, 0, mapElement.width, mapElement.height);
    }

    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.translate(-x, -y);
    //draw arrow
    ctx.beginPath();
    //stem
    ctx.moveTo(x, y - 20);
    ctx.lineTo(x, y + 20);
    //left thiungy
    ctx.moveTo(x - 5, y - 15);
    ctx.lineTo(x, y - 20);
    //right thungy
    ctx.moveTo(x + 5, y - 15);
    ctx.lineTo(x, y - 20);

    ctx.restore();

    //circles
    for (var i = 0; i < positions.length; i++) {
    	var pos = positions[i];
    	var p = world2map(new THREE.Vector2(pos[0], pos[2]));
	ctx.moveTo(p.x + 5, p.y);
    	ctx.arc(p.x, p.y, 5, 0, Math.PI * 2, true); 
    }

    ctx.stroke();
    ctx.closePath();

}

function loadMaterials(baseUrl) {
    console.log('Loading materials from ' + baseUrl);
    var fileNames = ['nx.png', 'px.png', 'py.png', 'ny.png', 'pz.png', 'nz.png']
    for (var i in fileNames) {
	cube.geometry.materials[i] = loadTexture(baseUrl + fileNames[i])
    }
}


function getPreviewImages() {
    var url = screenshot_server + '/preview?';
    for (var i = 0; i < positions.length; i++) {
        var pos = positions[i];
        url += 'p' + i + '=' + pos[0] + ',' + pos[1] + ',' + pos[2];
        if (i < positions.length - 1) {
            url += '&';
        }
    }
    console.log('getting preview images from', url);
    sendRequest(url, function(req) {
        previewReady = true;
        console.log('preview images are ready');
        var fileNames = ['nx.png', 'px.png', 'py.png', 'ny.png', 'pz.png', 'nz.png']
        for (var i = 0; i < positions.length; i++) {
            for (var j in fileNames) {
                var pos = positions[i][0] + ',' + positions[i][1] + ',' + positions[i][2]
	        previewMaterials[i][j] = loadTexture('http://localhost/tundra/' + pos + '/' + fileNames[j]);
            }
        }
    });
}


function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

    render();
}

function loadTexture(path) {

    var texture = new THREE.Texture(texture_placeholder);
    var material = new THREE.MeshBasicMaterial({ map: texture, overdraw: true });

    var image = new Image();
    image.crossOrigin = "anonymous";

    image.onload = function () {
        texture.needsUpdate = true;
        material.map.image = this;
        render();

    };
    image.src = path;

    return material;
}

function changePlace(x, y, z, rotY, rotX) {
    console.log('Change place', x, y, z, rotY);   
    url = screenshot_server + "/cubeimg?posX=" + x + "&posY=" + y + "&posZ=" + z;
    url += '&res=' + size;

    // FIXME 180 is for Secret O scene
    lon = 180 - rotY;
    lat = rotX;
    
    if (previewReady) {
        console.log('Preview images are ready');
        var ready = true
        if (previewMaterials[index].length == 6) {
            for (var i = 0; i < 6; i++) {
                if (previewMaterials[index][i] === undefined) {
                    ready = false;
                }
            }
        }
        
        if (ready) {
            console.log("Got all preview materials");
            for (i = 0; i < 6; i++) {
                cube.geometry.materials[i] = previewMaterials[index][i];
            }
        } else {
            var previewUrl = 'http://localhost/tundra/' + x + ',' + y + ',' + z + '/'
            console.log('using non-loaded images from', previewUrl);
            loadMaterials(previewUrl);
        }
    } else {
        for (var i = 0; i < 6; i ++) {
            materials[i] = loadMaterial;
        }
    }
    sendRequest(url, function(req) {
	var imageBaseUrl = req.responseText;
	console.log('loading from ' + imageBaseUrl);
	loadMaterials(imageBaseUrl);
    });
    
    render();
}

function onDocumentKeyUp(event) {
    if (event.keyCode == 78) {
	index = (index + 1) % positions.length;
	var p = positions[index]
	changePlace(p[0], p[1], p[2], p[3], p[4]);
    }
}

function onDocumentMouseDown(event) {
    event.preventDefault();

    isUserInteracting = true;

    onPointerDownPointerX = event.clientX;
    onPointerDownPointerY = event.clientY;

    onPointerDownLon = lon;
    onPointerDownLat = lat;

}

function onDocumentMouseMove(event) {

    if (isUserInteracting) {

        lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
        lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        render();

    }

}

function onDocumentMouseUp(event) {

    isUserInteracting = false;
    render();

}

function onDocumentMouseWheel(event) {

    camera.fov -= event.wheelDeltaY * 0.05;
    camera.updateProjectionMatrix();

    render();

}


function onDocumentTouchStart(event) {

    if (event.touches.length == 1) {

        event.preventDefault();

        onPointerDownPointerX = event.touches[ 0 ].pageX;
        onPointerDownPointerY = event.touches[ 0 ].pageY;

        onPointerDownLon = lon;
        onPointerDownLat = lat;

    }

}

function onDocumentTouchMove(event) {

    if (event.touches.length == 1) {

        event.preventDefault();

        lon = (onPointerDownPointerX - event.touches[0].pageX) * 0.1 + onPointerDownLon;
        lat = (event.touches[0].pageY - onPointerDownPointerY) * 0.1 + onPointerDownLat;

        render();

    }

}

function render() {
    lat = Math.max(- 85, Math.min(85, lat));
    phi = (90 - lat) * Math.PI / 180;
    theta = lon * Math.PI / 180;

    target.x = 500 * Math.sin(phi) * Math.cos(theta);
    target.y = 500 * Math.cos(phi);
    target.z = 500 * Math.sin(phi) * Math.sin(theta);

    camera.lookAt(target);

    renderer.render(scene, camera);
    
    drawMap(positions[index][0], positions[index][2], theta);

}

//from http://www.quirksmode.org/js/xmlhttp.html
function sendRequest(url,callback,postData) {
    var req = createXMLHTTPObject();
    if (!req) return;
    var method = (postData) ? "POST" : "GET";
    req.open(method,url,true);
    //req.setRequestHeader('User-Agent','XMLHTTP/1.0');
    if (postData)
	req.setRequestHeader('Content-type','application/x-www-form-urlencoded');
    req.onreadystatechange = function () {
	if (req.readyState != 4) return;
	if (req.status != 200 && req.status != 304) {
	    //alert('HTTP error ' + req.status);
            console.log('ERROR: ' + url + ", " + req.status);
	    return;
	}
	callback(req);
    }
    if (req.readyState == 4) return;
    req.send(postData);
}

function createXMLHTTPObject() {
    var xmlhttp = false;
    for (var i=0;i<XMLHttpFactories.length;i++) {
	try {
	    xmlhttp = XMLHttpFactories[i]();
	}
	catch (e) {
	    continue;
	}
	break;
    }
    return xmlhttp;
}

        </script>
    </body>
</html>
